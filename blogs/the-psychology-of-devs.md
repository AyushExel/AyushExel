Isn't it strange that there are so many tools that do almost the same thing but out of the 2 biggest players one has the most market share? It is like that for almost every tool, not just devtools
but that's beside the point. Why is it so? Let us get to the probable answers by elimination. 

- ### Could it be a first mover advantage?
First mover advantage is huge and generally underappriciated. Also the duration of lag time that a first-mover gets, and if they're smart about it, they tend to utilize it for product research. That 
allows them to create specific features and lock-in their largest clients and aggressively push for self-serve. Its almost always the playbook a successfull devtool saas. But again, I digressed a little.
This blog isn't about "how to create a commerically successful devtool saas", its about understanding what makes devs love a tool. Making it commercially viable is much easier if a tool is loved by
everyone.

In that case, if you look carefully, there are so many first movers( or even tools with low launch time-lag; its a term I use for tools that get founded during relatively similar timelines ),
in just the ML OSS space but they're not really market leaders. Tensorflow is the prime example and its something I'll keep coming back to because its the best case-study for so many things as devtool
should do and avoid. But ofcourse there are others as well. One thought excercise is going back to all the tools you use daily and figure out which of them is a current market leader but not the first/early-mover.

So, no, first-mover advantage, although helpful, isn't a sufficient condition for creating a winner.

- ### Maybe, better DevEx/UX
A very abused term, user experience or in this case developer experience is something people(including me) resort to when they don't want to do the intellectual work of studying their instincs as to why a particular
design seems better than the other. And we typically throw some umbrella terms like - it seems more "user friendly" or "natural". Not to be confused with other umbrella terms that actually convey something 
important like a tool seeming "familiar". I'll probably cover it later, but won't promise while writing this section.

So yes, without a doubt devEx is an important factor when it comes to success of a tool, but its a controversial topic. There is no metric to detemine what's good devEx, and once you're successful or a failure, there is
no need to determine that. So, how you go about **building features and getting them adopted in a scientific manner, i.e, create a process with a set of steps that if executed in order, will always produce the 
desired result .** Everything else and all other philosophies are just hunches that might've worked. It all boils down to the fact that if you cannot exlpain a phenomenon, you don't understant it.

- ### So, what makes a good UX
  
Time to step into users' shoes. What are some traits of humans in general, not just devs. 

**Low attention span**

**Not wanting to put intellectual effort into learning something new unless absolutely required to**

**Wanting to make use of existing skillset in future endeavors, or simply put transferability**

**Having a quick & easy determinant of progress, for dopamine release periodically**

I won't explain the "WHY" of above pointers too much in writing (but probably will in a complementary video that I might make on this. It'll be linked somewhere on this blog. I got this idea while writing this that I should 
probably make a video just going through this blog that'll allow me to go in-depth on each pointer, that I can't do by writing as it takes more time)
But I want to focus more on "HOW" this information can be helpful as a tool creator. Things will start to get more technical and specific from this point.

### Pre-requisite for designing good UX
One of the most difficult learnings that I've had and have also heard from other good contacts is deciding when you're supposed to guess on user's behalf and when you go all out
looking for feedback to iterate upon. It's uderstandable why its so difficult. Think about it - these statements are all true depending on time and perspective - "User is 
always right", "Iterate fast on feedback", & "Users don't know what they want and sometimes you've got to nudge them".

Depending on the stage of you project, any or all of them can be true. But they're all contradicting - one requires you to put yourself in shoes of the potential user and think of the ideal experience that should have when using a finished product. The other basically asks for feedback and iterates.

So how do you know what applies to you? One mental excercise that I have is - If you're confused about where you stand, you might be right. And if you sure you're right, you're definitely doing something wrong. So, ideally, this framework is designed to keep you in the doubtful questioning mode constantly, and then if the feedback starts flowing in,
you know that the "User is always right" and you've got to "Iterate fast on feedback"; if not then probably you haven't been showing users things interesting enough to nudge 
them to try your tool. 
Just remember this  thought excercise is designed to be done constantly, not just once you design the APIs, but at every feature level. 

OK now onto the next part where I'll cover the previous section.

- **Low attention span** and **Not wanting to put intellectual effort into learning something new unless absolutely required to** are pretty much the same outcome of different
  phenomema. First, fails to establish the value prop of a tool **(New idea, bad API)** while the 2nd has implicit value but the mental investment needed seems too high. **(Established idea, bad API)** 

- **Wanting to make use of existing skillset in future endeavors, or simply put transferability** - This is basically what the umbrella term "familiarity" practically is. It is a way of introducing user to new features, based off of their existing stack. It is probably the most  common way of creating vendor lockins as well but again, that is beyond the scope. For example, someone using a nosql DB for managing application data would much rather use the same tool's extension to manage searching unless the tradeoffs are
  significant. Selling them a new API via an independent tool that does the same thing will most likely fail unless the tradeoff isn't dramatic. This'll put us back to one of the
  2 problems discussed above.

- **Having a quick & easy determinant of progress, for dopamine release periodically** 

[..............TO BE CONTINUED..............]




